# java-data-structure-practice
  ## 학습 목표 
   - 알고리즘 학습 전 자바로 자료구조, 기초수학 학습하기
   - 이론을 실제 자바로 구현하기
   - 학습과 동시에 git 활용 방법 적응하기

# [기초수학]
### 기초수학-1주차
    1. git, project setting
        (1) git과 프로젝트 연동
            - 인텔: [Sytem Build: Gradle], [JDK: Oracle 21]로 프로젝트 생성
            - 인텔: Git-Github에 repository 생성
            - cmd: [branch 전환: $ git branch -b {전환할 이름}] 
        (2) 환경 설정 - 자바 인텔 한글깨짐(Gradle) 설정
            - [File]-[Settings]-[File Encodings]-Global, [Project Encoding, Properties Files 설정: UTF-8]
            - [File]-[Settings]-[Build, Exexcution Deplyment]-[Gradle]: 모두 Intellij IDEA 변경

    2. practice: 집합
        (1) Set function(java.util.HashSet)
            - 자바에서 집합 사용: HashSet 이용
            - HashSet은 새로운 객체로 결과값을 리턴하는 것이 아니므로 새로운 객체를 리턴하는 MySet 설정
        (2) MySet: 공통-반환을 위한 새로운 객체(파라미터X)를 만들고, 파라미터를 입력받는 생성자를 통해 기능처리(중복X)
            - 교집합(retianAll(MySet b)): 자기 자신의 리스트를 순회하면서 파라미터 값으로 새로 들어오는 리스트 또한 
                순회하여 같은 값이 있다면 새로운 객체에 담아 반환
            - 합집합(addAll(MySet b)): 자기 자신의 리스트를 순회하며 새로 반환할 객체에 담고, 새로 들어온 객체의 
                리스트에서 중복되지 않는 값 또한 넣어 반환
            - 차집합(removeAll(MySet b)): 자기 자신의 리스트를 순회하면서 새로 들어온 객체의 리스트도 순회하며 같은   
                값이 없다면 새로운 객체에 값을 담아 리턴함
### 기초수학-2주차
    1. practice: 경우의 수
        (1) 경우의 수-곱의 법칙과 합의 법칙
            - 곱의 법칙: 사건A 와 사건B 가 동시에 일어날 경우의 수
            - 합의 법칙: 사건A 또는 사건B 가일어날 경우의 수
        (2) 약수: (M % N == 0)일 경우, N은 M의 약수임(0 < N <= M)
        (3) 최대공약수(GCD): A와 B의 공통 약수이면서 가장 큰 수
            - 자신의 수의 절반 이하만 약수임, 예외는 자기 자신
        (4) 최소공배수(LCM): A와 B의 공통 약수이면서 가장 작은 수
            >> LCM = A*B / GCD
### 기초수학-3주차
    1. practice: 순열
        (1) 팩토리얼(Factorial): 1~n까지의 모든 자연수의 곱
            >> n! = n(n-1)(n-2)...1
        (2) 순열(Permutation): 순서를 정하여 나열, 서로 다른 n개 줄에 r개를 선택하는 경우의 수(순서O, 중복X)
            >> nPr = n!/(n-r)! = n(n-1)(n-2)...(n-r+1) (0<r<=n)
            * practice 1
                -자릿수를 바꿔나가면서 앞의 뽑는 개수(r)만큼 확인하여 경우의 수 추출
                -swap을 이용하여 자릿수를 바꿈
                -재귀함수를 이용하여 호출할 때마다 depth를 늘려 자릿수 변경
                -원하는 자릿수(r)만큼 만들어졌다면 원소를 추출하고 전으로 돌아감 -> 반복
            * practice 2
                -visited[]를 이용하여 해당 자리를 방문했을 경우 true, 방문하지 않았다면 false를 나타냄
                -해당 자리를 방문하지 않았다면 방문을 알리고(true), 그 자리를 out[]에 저장 후 재귀함수를 통해 다음으로 넘어감
                -원하는 자깃수(r)만큼 반복된 경우 원소를 추출하고 이전으로 돌아가 반복
        (3) 중복 순열(Duplicate Permutation): 서로 다른 n개 중에 r개를 선택하는 경우의 수(순서O, 중복O)
            >> n^r
        (4) 원 순열(Circle Permutation): 원 모양의 테이블에 n개의 원소를 나열하는 경우의 수
            >> (n-1)!
### 기초수학-4주차
    1. practice: 조합
        - 순열과 팩토리얼을 이용해 구현 가능
        (1) 조합(Combination): 서로 다른 n개 중에서 r개를 선택하는 경우의 수(순서X,중복X)
            >> nCr = n!/(n-r)!*r! = nPr/r! = n(n-1)(n-2)...(n-r+1)/r(r-1)...1
            * week3의 *practice2를 이용하여 구현
                -현재 함수가 방문하고 있는 자릿수를 true로 표시
                -재귀함수를 이용하여 자릿수+1을 파라미터 값으로 넘기고, 앞서 원소 하나를 뽑았으므로 뽑을 개수-1을 넣어 전달
                -위를 반복하다 원소를 다 뽑으면(r==0) 그동안의 원소를 호출하고 돌아감
                -돌아와서 방문하고 있던 자릿수를 false로 바꾸고, 재귀함수를 이용해 자릿수+1을 넘김
                -위를 반복하여 원소를 추출하고 자릿수가 끝까지 다 돌면 종료함
        (2) 중복 조합(Duplicate Combination): 서로 다른 n개 중에서 r개를 선택하는 경우의 수(순서X,중복O)
            >> nHr = (n+r-1)Cr
### 기초수학-5주차
    1. practice: 정화식과 재귀함수
        (1) 정화식(Recurrence): 어떤 수열의 일반항을 그 이전의 항들을 이용하여 정의한 식
            >> F1 = F2 = 1, F(n+2) = F(n+1) + F(n) //피보나치 수열
        (2) 재귀 함수(Recursive Function): 어떤 함수가 자신을 다시 호출하여 작업을 수행하는 방식
            *Practice1: factorial을 재귀함수로 구현
                -현재 수의 factorial = 현재의 수*이전의 수 이므로 return값에 넣어줌
                -종료 조건식으로 현재의 수가 1이되는 경우에는 1을 리턴하며 종료
            *Practice2: 최대공약수를 재귀함수로 구현
                -최대공약수는 두 수의 공통 약수 중 가장 큰 수를 구하는 것이므로
                -두 수의 공통점을 찾기 위해 두 수를 서로 나누고 나머지 구해서 나누는 것을 반복하면서
                -처음으로 나머지가 0이 되는 경우가 둘이 서로 가진 약수 중 가장 큰 수임 
### 기초수학-6주차
    1. practice: 지수와 로그
        (1) 제곱(pow): 같은 수를 두번 곱함, 거듭제곱: 같은 수를 거듭하여 곱함
            *마이너스 지수를 적용하기 위해 마이너스 유무를 판단하여 마이너스인 경우 역수를 취함
        (2) 제곱근(sqrt): a를 제곱하여 b가 될 때, a를 b의 제곱근이라고 함
            *바빌로니아법 이용: 반복할수록 제곱근의 근사값에 접근
        (3) 로그(log): a가 b로 되기 위해 제곱해야 하는 횟수
### 기초수학-7주차
    1.practice: 알고리즘 복잡도
        (1) 복잡도(Complexity): 알고리즘의 성능을 나타내는 척도, 시간 복잡도와 공간 복잡도는 Trade-off관계
            -빅오 표기법 사용(Big O): 최악의 경우 기준
        (2) 시간 복잡도(Time Complexity): 알고리즘의 필요 연산 횟수
            >> [낮은 복잡도] O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) [높은 복잡도]
        (3) 공간 복잡도(Space Complexity): 알고리즘의 필요 메모리 사용량

# [자료구조]
### 자료구조-1주차
    1. practice: 배열
        *pracrice: 생성된 배열에서 요소를 삭제하거나 추가하기 위해서는 
            (삭제) 
                배열에 같은 값을 가지는 요소가 있는지 확인 후, 있다면 그 값의 인덱스를 구하고 인덱스를 기준으로   
                새로운 배열(기존의 길이-1)에 기존 값 추가, 타겟 인덱스 후의 값도 추가하여 길이조정된 새로운 배열을 생성
            (추가) 
                기존 배열의 길이보다 인덱스의 크기가 크지 않은지 확인 후. 넣고 싶은 인덱스 자리를 기준으로 
                새로운 배열(기존의 길이+1)에 기존 값 추가, 타겟 인덱스 후의 값도 추가 후 타겟 인덱스에 데이터를 삽입하여 
                새로운 배열을 생성
        (1) 배열(Array)
            -많은 수의 데이터를 다룰 때 사용하는 자료구조
            -각 데이터를 인덱스와 1:1 대응
            -데이터가 메모리 상에 연속적인 저잘
        (2) 장점: 인덱스를 이용하여 데이터에 빠르게 접근 가능
        (3) 단점: 데이터의 추가/삭제가 번거로움
            -미리 최대길이를 정해서 생성
            -가변 길이 배열은 배열의 크기를 변경할 때마다 새로운 배열을 생성
            -데아터 삭제 시, 인덱스를 유지하기 위해 빈공간 유지
### 자료구조-2주차
    1. practice: 연결 리스트
        *practice1: 단순 연결리스트(Simple Linked List) 구현
        *practice2: 양방향 연결리스트(Doubly Linked List) 구현
        *practice3: 원형 연결리스트(Circle Linked List) 구현
        (1) 연결 리스트(Linked List)
            -데이터를 링크로 연결해서 관리하는 자료구조
            -자료의 순서 존재, 메모리상 연속성 존재X
        (2) 장점
            -데이터 공간을 미리 할당할 필요X
            -리스트의 길이가 가변적 --> 데이터 삭제,추가 용이
        (3) 단점
            -연결 구조를 위한 별도의 데이터 공간 필요(Node)
            -연결 정보를 찾는 시간 필요(상대적 접근속도 느림)
            -데이터 추가,삭제 시 앞 뒤 데이터의 연결을 재구성하는 작업 필요
        (4) 연결 리스트의 기본 구조
            *노드(Node): 데이터 저장 단위, 값, 포인터로 구성
                -포인터(Pointer): 다음 노드나 이전 노드의 연결정보
                -데이터나 링크는 여러개 존재 가능
            *데이터 추가(addData): 데이터 추가 위치(head, 중간, tail)에 따른 연결 작업 필요
                [가장 앞에 추가-head]: 추가 할 데이터 담을 노드 생성 -> 링크 연결 작업 -> head 이전(prev) 작업
                [중간에 추가]: 추가할 데이터를 담을 노드 생성 -> head로부터 데이터 추가 위치 직전까지 순회 -> 링크 연결 작업
                [끝에 추가-tail]: 추가할 데이터를 담는 노드 생성 -> head로부터 끝노드까지 순회 -> 링크 연결 작업
            *데이터 삭제(removeData): 데이터 삭제 위치(head, 중간, tail)에 따른 연결 작업 필요
                [가장 앞에 삭제-head]: 삭제 대상 노드 지정 -> head이전 작업 -> 대상 삭제
                [중간 삭제]: head부터 삭제 대상까지 순회, 해당 노드 지정 -> 삭제 대상 이전(prev)/이후(next) 링크 연결 작업 -> 대상 삭제
                [끝 삭제=tail]: head부터 끝까지 순회 -> 끝 노드 삭제 -> 삭제 이전(prev)의 노드의 링크 처리
### 자료구조-3주차
    1. practice: 스택
        *practice1: ArrayList로 스택 구현
        *practice2: Array로 스택 구현
        (1) 스택(Stack)
            -후입 선출(Last In First Out, LIFO): 마지막에 들어온 데이터가 먼저 나감
            -데이터가 입력된 순서의 역순으로 처리되어야 할 때 사용
        (2) 스택 기본 구조
            -Top: 스택 공간 중 가장 마지막에 들어온 데이터/Bottom: 스택 구조 중 가장 먼저 들어온 데이터
            -데이터 추가(Push): 스택의 가장 마지막 위치에 데이터 추가
            -데이터 꺼내기(Pop): 스택의 가장 마지막 위치에서 데이터 꺼냄
### 자료구조-4주차
    1. practice: 큐
        *practice1: ArrayList를 이용한 Queue
        *practice2: Array를 이용한 원형 Queue
        (1) 큐(Queue)
            -선입선출(First In First Out,FIFO): 먼저 들어온 데이터가 먼저 나감
            -입력 순서대로 데이터 처리가 필요한 경우
        (2) 큐 기본 구조
            -front: 큐 공간 중 맨 먼저 나가는 위치/rear: 큐 공간 중 맨 마지막에 나가는 위치
            -데이터 추가(Enqueue): 큐에 데이터 추가
            -데이터 꺼내기(Dequeue): 큐에서 데이터 꺼내기
### 자료구조-5주차
    1. practice: 데크
        *practice1: ArrayList를 이용한 데크 구현
        *practice2: Array를 이용한 데크 구현
            -원형으로 관리하기 위해 만들려는 사이즈+1 처리 <-- front 앞자리는 비워두기 때문
            -데크 공간의 마지막 자리에서 +1을 하고 데크 공간만큼 빠졌을 때 front의 위치와 같다면 데크는 가득참을 의미
            -front는 데이터가 추가될수록 앞으로 쌓이므로 위치는 -1씩 변하는데, 원형으로 관리하기 위해 
                생성된 배열만큼 더함
        (1) 데크(Deque): 양쪽에서 삽입/삭제가 모두 가능한 자료구조
            -Deque: Doubly-ended Queue
            -Stack + Queue
        (2) 데크 기본 구조
            -용어(Front: -First, Rear: -Last)
                -add(offer): 추가
                -remove(poll): 삭제
                    *remove는 데크에 데이터가 없으면 에러를 throw, poll은 null을 리턴
            -일부 기능을 제한하여 용도에 맞게 변형가능
        (3) 입력 제한한 데크(Scroll): 한 쪽의 입력을 제한한 데크
        (4) 출력 제한한 데크(Shelf): 한 쪽의 출력을 제한한 데크

            